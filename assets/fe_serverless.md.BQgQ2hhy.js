import{_ as e,c as a,o as r,a3 as s}from"./chunks/framework.BWtL4YFW.js";const u=JSON.parse('{"title":"serverless","description":"","frontmatter":{"title":"serverless","date":"2020-04-01T16:55:10.000Z","tags":"server"},"headers":[],"relativePath":"fe/serverless.md","filePath":"fe/serverless.md","lastUpdated":1716009680000}'),l={name:"fe/serverless.md"},o=s('<p><a href="https://www.jianshu.com/p/92632d6c2269" target="_blank" rel="noreferrer">参考一</a> <a href="https://zhuanlan.zhihu.com/p/84054729" target="_blank" rel="noreferrer">参考二</a></p><ul><li><p><a href="#前端开发模式的演进">前端开发模式的技术表格即技术演进</a></p></li><li><p><a href="#serverless">serverless常见服务商提供的解决方案</a></p></li><li><p><a href="#未来前端">基于serverless的前端开发模式</a></p></li></ul><h2 id="前端开发模式的演进" tabindex="-1">前端开发模式的演进 <a class="header-anchor" href="#前端开发模式的演进" aria-label="Permalink to &quot;前端开发模式的演进&quot;">​</a></h2><ol><li><a href="#模板渲染">基于php/java的模板渲染的动态页面</a></li><li><a href="#ajax">基于ajax的前后端分离模式</a></li><li><a href="#nodejs工程化">基于nodejs的前端工程化</a></li><li><a href="#nodejs全栈开发">基于nodejs的全栈开发</a></li></ol><h3 id="模板渲染" tabindex="-1">模板渲染 <a class="header-anchor" href="#模板渲染" aria-label="Permalink to &quot;模板渲染&quot;">​</a></h3><p>在早起的互联网时代，我们的网页很简单，就是一些静态或动态的页面，主要目的是用来做信息的展示和传播。这个时候开发一个网页也很easy，主要就是通过 JSP、PHP 等技术写一些动态模板，然后通过 Web Server（nginx，apache） 将模板解析成一个个 HTML 文件，浏览器只负责渲染这些 HTML 文件。这个阶段还没有前后端的分工，通常是后端工程师顺便写了前端页面。</p><p>JSP: Java Server Page: Java服务端页面，在html页面中编写Java代码的页面 WebServer：网站服务器或web服务器</p><h3 id="ajax" tabindex="-1">ajax <a class="header-anchor" href="#ajax" aria-label="Permalink to &quot;ajax&quot;">​</a></h3><p>2005 年 AJAX 技术的正式提出，翻开了 Web 开发的新篇章。基于 AJAX，我们可以把 Web 分为前端和后端，前端负责界面和交互，后端负责业务逻辑的处理。前后端通过接口进行数据交互。我们也不再需要在各个后端语言里面写着难以维护的 HTML。网页的复杂度也由后端的 Web Server 转向了浏览器端的 JavaScript。也正因如此，开始有了前端这个职位</p><h3 id="nodejs工程化" tabindex="-1">nodejs工程化 <a class="header-anchor" href="#nodejs工程化" aria-label="Permalink to &quot;nodejs工程化&quot;">​</a></h3><p>2009年 Node.js 的出现，对于前端来说，也是一个历史性的时刻。随着 Node.js 一同出现的还有 CommonJS 规范和 npm 包管理机制。随后也出现了 Grunt、Gulp、Webpack 等一系列基于 Node.js 的前端开发构建工具。</p><p>在 2013 年前后，前端三大框架 React.js/Angular/Vue.js 相继发布第一个版本。我们可以从以往基于一个个页面的开发，变为基于一个个组件进行开发。开发完成后使用 webpack 等工具进行打包构建，并通过基于 Node.js 实现的命令行工具将构建结果发布上线。前端开发开始变得规范化、标准化、工程化。</p><h3 id="nodej全栈开发" tabindex="-1">nodej全栈开发 <a class="header-anchor" href="#nodej全栈开发" aria-label="Permalink to &quot;nodej全栈开发&quot;">​</a></h3><p>Node.js 对前端的重要意义还有，以往只能运行在浏览器中的 js 也可以运行在服务器上，前端可以用自己最熟悉的语言来写服务端的代码。于是前端开始使用 Node.js 做全栈开发，开始由前端向全栈的方向转变。这是前端主动突破自己的边界。 另一方面，前端在发展，后端也在发展。也差不多在 Node.js 诞生那个时代，后端普遍开始由巨石应用模式向微服务架构转变。这也就导致以往的前后端分工出现了分歧。随着微服务架构的兴起，后端的接口渐渐变得原子性，微服务的接口也不再直接面向页面，前端的调用变得复杂了。于是 BFF（Backend For Frontend）架构出现了，在微服务和前端中间，加了一个 BFF 层，由 BFF 对接口进行聚合、裁剪后，再输出给前端。而 BFF 这层不是后端本质工作，且和前端的关系最大，所以前端自然而然选择了 Node.js 来实现。这也是当前 Node.js 在服务端较为广泛的应用的原因。</p><blockquote><p>巨石应用 大部分web工程是将所有的功能模块(service side)打包到一起并放在一个web容器中运行，很多企业的Java应用程序打包为war包</p></blockquote><blockquote><p>微服务架构 微服务架构是一种架构理念，是指将功能分解到离散的各个服务当中，从而降低系统的耦合性，并提供更加灵活的服务支持。把一个大型的单体应用程序和服务拆分为数个或数十个的微小型服务，它可扩展单个组件而不是整个的应用程序堆栈，从而满足服务等级协议。</p></blockquote><h2 id="serverless" tabindex="-1">serverless <a class="header-anchor" href="#serverless" aria-label="Permalink to &quot;serverless&quot;">​</a></h2><p>CNCF，全称Cloud Native Computing Foundation（云原生计算基金会），成立于 2015 年7月21日（于美国波特兰OSCON 2015上宣布），其最初的口号是坚持和整合开源技术来让编排容器作为微服务架构的一部分，其作为致力于云原生应用推广和普及的一支重要力量，不论您是云原生应用的开发者、管理者还是研究人员都有必要了解。</p><p>目前行业可能更多处在容器 Docker+Kubernetes, 利用 IaaS、PaaS和SaaS 来快速搭建部署应用</p><p>基础架构即服务（Infrastructure as a Service，IaaS）、平台即服务（Platform as a Service，PaaS）以及软件即服务（Software as a Service，SaaS）。</p><p>Docker是一个平台，它主要是提供一些服务，任何一台装有docker的机器你都可以建立、发布、运行你的应用程序，使用docker很省钱省时。 简单的介绍Kubernetes。它就是一套成熟的商用服务编排解决方案。Kubernetes定位在Paas层，重点解决了微服务大规模部署时的服务编排问题。</p><h4 id="其实-serverless-早已和前端产生了联系-只是我们可能没有感知" tabindex="-1">其实 Serverless 早已和前端产生了联系，只是我们可能没有感知 <a class="header-anchor" href="#其实-serverless-早已和前端产生了联系-只是我们可能没有感知" aria-label="Permalink to &quot;其实 Serverless 早已和前端产生了联系，只是我们可能没有感知&quot;">​</a></h4><ol><li><p>CDN: 相信大家都使用过 CDN，我们开发完成之后，直接将静态文件部署到 CDN 上，通过 CDN 进行内容分发、网络加速，在这个过程中，前端不需要关心 CDN 有多少个节点、如何做负载均衡，也不需要知道 CDN 的 QPS 是多少。所以从这个角度来说，CDN 是一种 serverless 的实现。</p></li><li><p>再比如对象存储，和 CDN 一样，我们只需要将文件上传到对象存储，就可以直接使用了，不需要关心它如何存取文件、如何进行权限控制，所以对象存储对前端来说是 Serverless。</p></li><li><p>甚至一些第三方的 API 服务，也是 Serverless，因为我们使用的时候，不需要去关心服务器。</p></li></ol><blockquote><p>当然，有了体感还不够，我们还是需要一个更精确的定义。从技术角度来说，Serverless 就是 FaaS 和 BaaS 的结合</p></blockquote><p>简单来讲，FaaS（Function as a Service） 就是一些运行函数的平台，比如阿里云的函数计算、AWS 的 Lambda 等。</p><p>BaaS（Backend as a Service）则是一些后端云服务，比如云数据库、对象存储、消息队列等。利用 BaaS，可以极大简化我们的应用开发难度。</p><p>Serverless 则可以理解为运行在 FaaS 中，使用了 BaaS 的函数。</p><h4 id="serverless的主要特点" tabindex="-1">Serverless的主要特点 <a class="header-anchor" href="#serverless的主要特点" aria-label="Permalink to &quot;Serverless的主要特点&quot;">​</a></h4><ol><li>事件驱动----函数在 FaaS 平台中，需要通过一系列的事件来驱动函数执行。</li><li>无状态----因为每次函数执行，可能使用的都是不同的容器，无法进行内存或数据共享。如果要共享数据，则只能通过第三方服务，比如Redis等。</li></ol><blockquote><p>Redis（全称：Remote Dictionary Server 远程字典服务）是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value[数据库]，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。</p></blockquote><ol start="3"><li>无运维----使用serverless我们不需要关心服务器，也不需要关心运维，这也是serverles思想的核心；</li><li>低成本----使用 Serverless 成本很低，因为我们只需要为每次函数的运行付费。函数不运行，则不花钱，也不会浪费服务器资源过度</li></ol><h4 id="常见服务商提供的解决方案" tabindex="-1">常见服务商提供的解决方案 <a class="header-anchor" href="#常见服务商提供的解决方案" aria-label="Permalink to &quot;常见服务商提供的解决方案&quot;">​</a></h4><p>1、上图是当前主要的一些 Serverless 服务，以及对应的服务解决方案。 2、从下往上，分别是基础设施、开发工具和应用场景。 亚马逊-微软-谷歌 3、基础设施主要是一些云计算厂商提供，包括云计算平台和各种 BaaS 服务，以及运行函数的 FaaS 平台。 前端主要是 Serverless 的使用者，所以对前端来说，最重要的开发工具这一层，我们需要依赖开发工具进行 Serverless 开发、调试和部署。 4、框架（Framework） 如今还没有一个统一的 Serverless 标准，不同云计算平台提供的 Serverless 服务很可能是不一样的，这就导致我们的代码，无法平滑迁移。Serverless 框架一个主要功能是简化 Serverless 开发、部署流程，另一主要功能则是屏蔽不同 Serverless 服务中的差异，让我们的函数能够在不改动或者只改动很小一部分的情况下，在其他 Serverless 服务中也能运行。常见的 Serverless 框架有 Serverless Framework、ZEIT Now、Apex 等。不过这些基本都是国外公司做的，国内还没有这样的平台。 5、Web IDE 和 Serverless 紧密相关的 Web IDE 主要也是各个云计算平台的 Web IDE。利用 Web IDE，我们可以很方便地在云端开发、调试函数，并且可以直接部署到对应的 FaaS 平台。这样的好处是避免了在本地安装各种开发工具、配置各种环境。常见的 Web IDE 有 AWS 的 Cloud9、阿里云的函数计算 Web IDE、腾讯云的 Cloud Studio。 6、当然，目前最主要的开发方式还是在本地进行开发。所以在本地开发 Serverless 的命令行工具也必不可少。 命令行工具主要有两类，一类是云计算平台提供的，如 AWS 的 aws、 Azure 的 az、阿里云的 fun；还有一类是 Serverless 框架提供的，如 serverless、now。 大部分工具如 serverless、fun 等，都是用 Node.js 语言来实现的。 7、应用场景 在开发工具上面一层，则是 Serverless 的一些垂直应用场景。除了使用传统的服务端开发，目前使用 Serverless 技术的还有小程序开发，未来可能还会涉及到物联网领域（IoT）。</p><h2 id="未来前端" tabindex="-1">未来前端 <a class="header-anchor" href="#未来前端" aria-label="Permalink to &quot;未来前端&quot;">​</a></h2><ul><li><p>在传统开发流程中，我们需要前端写页面，后端工程师写接口。后端写完接口之后，把接口部署了，再进行前后端联调。联调完毕后再测试、上线。上线之后，还需要运维工程师对系统进行维护。整个过程涉及多个不同角色，链路较长，沟通协调也是一个问题</p></li><li><p>基于 Serverless，后端变得非常简单，以往的后端应用被拆分为一个个函数，只需要写完函数并部署到 Serverless 服务即可，后续也不用关心任何服务器的运维操作。后端开发的门槛大幅度降低了。因此，只需要一个前端就可以完成所有的开发工作。 当然，前端基于 Serverless 去写后端，最好也需要具备一定的后端知识。涉及复杂的后端系统或者 Serverless 不适用的场景，还是需要后端开发。</p></li></ul><h6 id="使用-serverless-我们不需要再过多关注服务端的运维-不需要关心我们不熟悉的领域-我们只需要专注于业务的开发、专注于产品的实现。我们需要关心的事情变少了-但我们能做的事情更多了。" tabindex="-1">使用 Serverless，我们不需要再过多关注服务端的运维，不需要关心我们不熟悉的领域，我们只需要专注于业务的开发、专注于产品的实现。我们需要关心的事情变少了，但我们能做的事情更多了。 <a class="header-anchor" href="#使用-serverless-我们不需要再过多关注服务端的运维-不需要关心我们不熟悉的领域-我们只需要专注于业务的开发、专注于产品的实现。我们需要关心的事情变少了-但我们能做的事情更多了。" aria-label="Permalink to &quot;使用 Serverless，我们不需要再过多关注服务端的运维，不需要关心我们不熟悉的领域，我们只需要专注于业务的开发、专注于产品的实现。我们需要关心的事情变少了，但我们能做的事情更多了。&quot;">​</a></h6>',36),t=[o];function i(n,d,p,h,v,S){return r(),a("div",null,t)}const b=e(l,[["render",i]]);export{u as __pageData,b as default};
